<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
<title>NeonSnake - Scroll automatique</title>
<style>
  html, body {
    margin: 0; padding: 0; overflow-x: hidden; /* pas de scroll horizontal */
    background: #0a0a0a;
    color: #0ff;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    height: 100vh;
  }
  #gameContainer {
    position: relative;
    width: 100vw;
    height: 100vh;
    overflow: hidden;
    touch-action: none;
  }
  canvas {
    display: block;
    background: #111;
    margin: 0 auto;
    filter: drop-shadow(0 0 8px #0ff);
  }
  #scoreboard {
    position: fixed;
    top: 10px; left: 50%; transform: translateX(-50%);
    color: #0ff;
    font-size: 18px;
    user-select: none;
    z-index: 10;
    text-align: center;
  }
  #pseudoInput {
    position: fixed;
    top: 40px; left: 50%; transform: translateX(-50%);
    font-size: 16px;
    padding: 4px 8px;
    border: 1px solid #0ff;
    background: transparent;
    color: #0ff;
    outline: none;
    z-index: 10;
    width: 150px;
    text-align: center;
  }
  #pauseOverlay {
    position: fixed;
    top:0; left:0; width: 100vw; height: 100vh;
    background: rgba(0,0,0,0.8);
    color: #0ff;
    font-size: 24px;
    font-weight: bold;
    display: flex;
    justify-content: center;
    align-items: center;
    white-space: pre-line;
    text-align: center;
    cursor: pointer;
    user-select: none;
    z-index: 20;
    display: none;
  }
</style>
</head>
<body>
<div id="gameContainer">
  <canvas id="gameCanvas"></canvas>
  <div id="scoreboard">Score: 0</div>
  <input type="text" id="pseudoInput" placeholder="Ton pseudo" maxlength="15" />
  <div id="pauseOverlay">TOUCHE POUR JOUER</div>
</div>

<script>
(() => {
  // Constantes
  const WORLD_WIDTH = window.innerWidth;
  const WORLD_HEIGHT = window.innerHeight * 4; // zone 4x plus haute que la fenêtre
  const BORDER_THICKNESS = 20;
  const FOOD_COUNT = 25;
  const SNAKE_INITIAL_LENGTH = 10;

  // Éléments DOM
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');
  const scoreboard = document.getElementById('scoreboard');
  const pseudoInput = document.getElementById('pseudoInput');
  const pauseOverlay = document.getElementById('pauseOverlay');
  const gameContainer = document.getElementById('gameContainer');

  // Canvas taille fenêtre (viewport)
  canvas.width = WORLD_WIDTH;
  canvas.height = window.innerHeight;

  // Variables globales
  let isPaused = true;
  let score = 0;
  let pseudo = localStorage.getItem('neonsnake_pseudo') || '';
  pseudoInput.value = pseudo;

  // Position et direction tactile
  let touchActive = false;
  let touchStartX = 0, touchStartY = 0;
  let targetAngle = 0;

  // Classe pour le serpent
  class Snake {
    constructor(color, startX, startY) {
      this.color = color;
      this.segments = [];
      this.alive = true;
      this.radius = 12;
      this.speed = 3;
      this.angle = 0; // direction en radians
      this.targetAngle = 0; // angle vers lequel on tourne

      for(let i=0; i<SNAKE_INITIAL_LENGTH; i++) {
        this.segments.push({x: startX - i*this.radius*2, y: startY});
      }
    }

    update() {
      if(!this.alive) return;

      // Smooth rotation vers targetAngle
      let diff = this.targetAngle - this.angle;
      if(diff > Math.PI) diff -= 2 * Math.PI;
      if(diff < -Math.PI) diff += 2 * Math.PI;
      this.angle += diff * 0.15;

      // Calcul nouvelle tête
      let head = this.segments[0];
      let newX = head.x + Math.cos(this.angle) * this.speed;
      let newY = head.y + Math.sin(this.angle) * this.speed;

      // Check collision bord
      if(newX < BORDER_THICKNESS + this.radius || newX > WORLD_WIDTH - BORDER_THICKNESS - this.radius ||
         newY < BORDER_THICKNESS + this.radius || newY > WORLD_HEIGHT - BORDER_THICKNESS - this.radius) {
        this.alive = false;
        return;
      }

      // Avancer le serpent
      this.segments.unshift({x: newX, y: newY});
      this.segments.pop();
    }

    grow() {
      let tail = this.segments[this.segments.length -1];
      this.segments.push({x: tail.x, y: tail.y});
    }

    draw(ctx) {
      ctx.save();
      ctx.lineCap = 'round';

      // Dessin du corps (anneaux néon)
      for(let i = this.segments.length - 1; i > 0; i--) {
        let seg = this.segments[i];
        let alpha = 0.6 * (i / this.segments.length);
        ctx.strokeStyle = `rgba(0,255,255,${alpha})`;
        ctx.lineWidth = this.radius * 2;
        ctx.beginPath();
        ctx.moveTo(seg.x, seg.y);
        ctx.lineTo(this.segments[i-1].x, this.segments[i-1].y);
        ctx.stroke();
      }

      // Dessin de la tête
      let head = this.segments[0];
      ctx.fillStyle = '#0ff';
      ctx.beginPath();
      ctx.arc(head.x, head.y, this.radius, 0, 2*Math.PI);
      ctx.fill();

      // Dessin des yeux
      const eyeOffsetAngle = Math.PI / 6;
      const eyeDistance = this.radius * 0.6;
      const eyeRadius = this.radius * 0.2;

      // Oeil gauche
      let eyeLX = head.x + Math.cos(this.angle - eyeOffsetAngle) * eyeDistance;
      let eyeLY = head.y + Math.sin(this.angle - eyeOffsetAngle) * eyeDistance;
      ctx.fillStyle = '#fff';
      ctx.beginPath();
      ctx.arc(eyeLX, eyeLY, eyeRadius, 0, 2*Math.PI);
      ctx.fill();

      // Pupille gauche
      ctx.fillStyle = '#000';
      ctx.beginPath();
      ctx.arc(eyeLX, eyeLY, eyeRadius * 0.5, 0, 2*Math.PI);
      ctx.fill();

      // Oeil droit
      let eyeRX = head.x + Math.cos(this.angle + eyeOffsetAngle) * eyeDistance;
      let eyeRY = head.y + Math.sin(this.angle + eyeOffsetAngle) * eyeDistance;
      ctx.fillStyle = '#fff';
      ctx.beginPath();
      ctx.arc(eyeRX, eyeRY, eyeRadius, 0, 2*Math.PI);
      ctx.fill();

      // Pupille droite
      ctx.fillStyle = '#000';
      ctx.beginPath();
      ctx.arc(eyeRX, eyeRY, eyeRadius * 0.5, 0, 2*Math.PI);
      ctx.fill();

      ctx.restore();
    }
  }

  // Nourriture
  class Food {
    constructor(x,y) {
      this.x = x;
      this.y = y;
      this.radius = 8;
    }

    draw(ctx) {
      ctx.save();
      ctx.fillStyle = '#0ff';
      ctx.shadowColor = '#0ff';
      ctx.shadowBlur = 20;
      ctx.beginPath();
      ctx.arc(this.x, this.y, this.radius, 0, 2*Math.PI);
      ctx.fill();
      ctx.restore();
    }
  }

  // Génère la nourriture au hasard, sans être dans les bordures
  function generateFoods() {
    foods = [];
    for(let i=0; i<FOOD_COUNT; i++) {
      let x = BORDER_THICKNESS + 20 + Math.random() * (WORLD_WIDTH - 2*BORDER_THICKNESS - 40);
      let y = BORDER_THICKNESS + 20 + Math.random() * (WORLD_HEIGHT - 2*BORDER_THICKNESS - 40);
      foods.push(new Food(x,y));
    }
  }

  // Variables jeu
  let playerSnake = new Snake('#0ff', WORLD_WIDTH/2, WORLD_HEIGHT/2);
  let foods = [];
  generateFoods();

  // Score
  function updateScoreDisplay() {
    scoreboard.textContent = `Score: ${score}`;
  }

  // Gestion pseudo
  pseudoInput.addEventListener('input', () => {
    pseudo = pseudoInput.value.trim();
    localStorage.setItem('neonsnake_pseudo', pseudo);
    if(pseudo.length > 0 && isPaused) {
      isPaused = false;
      pauseOverlay.style.display = 'none';
    }
  });

  // Touches tactiles pour tourner le serpent
  gameContainer.addEventListener('touchstart', (e) => {
    e.preventDefault();
    if(!playerSnake.alive) return;
    touchActive = true;
    let touch = e.touches[0];
    touchStartX = touch.clientX;
    touchStartY = touch.clientY;
  }, {passive:false});

  gameContainer.addEventListener('touchmove', (e) => {
    e.preventDefault();
    if(!playerSnake.alive) return;
    if(!touchActive) return;
    let touch = e.touches[0];
    let dx = touch.clientX - touchStartX;
    let dy = touch.clientY - touchStartY;
    if(dx === 0 && dy === 0) return;
    playerSnake.targetAngle = Math.atan2(dy, dx);
  }, {passive:false});

  gameContainer.addEventListener('touchend', (e) => {
    e.preventDefault();
    touchActive = false;
    // Pause le jeu quand on arrête de toucher
    if(playerSnake.alive) {
      isPaused = true;
      pauseOverlay.textContent = 'PAUSE\nTOUCHE POUR REPRENDRE';
      pauseOverlay.style.display = 'flex';
    }
  }, {passive:false});

  // Reprise au toucher sur overlay
  pauseOverlay.addEventListener('touchstart', (e) => {
    e.preventDefault();
    if(!playerSnake.alive) {
      resetGame();
    } else {
      isPaused = false;
      pauseOverlay.style.display = 'none';
    }
  }, {passive:false});

  pauseOverlay.addEventListener('click', () => {
    if(!playerSnake.alive) {
      resetGame();
    } else {
      isPaused = false;
      pauseOverlay.style.display = 'none';
    }
  });

  // Reset du jeu
  function resetGame() {
    score = 0;
    updateScoreDisplay();
    playerSnake = new Snake('#0ff', WORLD_WIDTH/2, WORLD_HEIGHT/2);
    generateFoods();
    isPaused = false;
    pauseOverlay.style.display = 'none';
    // Recentrer scroll sur la position de départ
    window.scrollTo(0, WORLD_HEIGHT/2 - window.innerHeight/2);
  }

  // Fonction pour détecter collision cercle-cercle
  function circlesCollide(x1,y1,r1,x2,y2,r2) {
    let dx = x1 - x2;
    let dy = y1 - y2;
    let dist = Math.sqrt(dx*dx + dy*dy);
    return dist < r1 + r2;
  }

  // Affichage des barrières rouges et blanches (type chantier)
  function drawBorders(ctx) {
    const stripeWidth = BORDER_THICKNESS;
    const stripeHeight = 40;
    ctx.save();

    // Couleur de base
    ctx.fillStyle = '#000';

    // Haut
    ctx.fillRect(0, 0, WORLD_WIDTH, BORDER_THICKNESS);
    // Bas
    ctx.fillRect(0, WORLD_HEIGHT - BORDER_THICKNESS, WORLD_WIDTH, BORDER_THICKNESS);
    // Gauche
    ctx.fillRect(0, 0, BORDER_THICKNESS, WORLD_HEIGHT);
    // Droite
    ctx.fillRect(WORLD_WIDTH - BORDER_THICKNESS, 0, BORDER_THICKNESS, WORLD_HEIGHT);

    // Stripes diagonales rouges/blanches haut
    for(let x=0; x < WORLD_WIDTH; x += stripeHeight) {
      ctx.fillStyle = (Math.floor(x/stripeHeight) % 2 === 0) ? '#f00' : '#fff';
      ctx.beginPath();
      ctx.moveTo(x, 0);
      ctx.lineTo(x + stripeHeight, 0);
      ctx.lineTo(x, BORDER_THICKNESS);
      ctx.closePath();
      ctx.fill();
    }
    // Bas
    for(let x=0; x < WORLD_WIDTH; x += stripeHeight) {
      ctx.fillStyle = (Math.floor(x/stripeHeight) % 2 === 0) ? '#fff' : '#f00';
      ctx.beginPath();
      ctx.moveTo(x, WORLD_HEIGHT);
      ctx.lineTo(x + stripeHeight, WORLD_HEIGHT);
      ctx.lineTo(x, WORLD_HEIGHT - BORDER_THICKNESS);
      ctx.closePath();
      ctx.fill();
    }
    // Gauche
    for(let y=0; y < WORLD_HEIGHT; y += stripeHeight) {
      ctx.fillStyle = (Math.floor(y/stripeHeight) % 2 === 0) ? '#f00' : '#fff';
      ctx.beginPath();
      ctx.moveTo(0, y);
      ctx.lineTo(0, y + stripeHeight);
      ctx.lineTo(BORDER_THICKNESS, y);
      ctx.closePath();
      ctx.fill();
    }
    // Droite
    for(let y=0; y < WORLD_HEIGHT; y += stripeHeight) {
      ctx.fillStyle = (Math.floor(y/stripeHeight) % 2 === 0) ? '#fff' : '#f00';
      ctx.beginPath();
      ctx.moveTo(WORLD_WIDTH, y);
      ctx.lineTo(WORLD_WIDTH, y + stripeHeight);
      ctx.lineTo(WORLD_WIDTH - BORDER_THICKNESS, y);
      ctx.closePath();
      ctx.fill();
    }
    ctx.restore();
  }

  // Scroll automatique vertical pour garder le serpent visible
  function autoScroll() {
    let head = playerSnake.segments[0];
    const margin = 100; // marge avant que la page scrolle
    let scrollY = window.scrollY;

    if(head.y - scrollY < margin) {
      // serpent proche du haut de la fenêtre -> scroll vers le haut (min 0)
      let newScroll = Math.max(0, head.y - margin);
      window.scrollTo(0, newScroll);
    } else if(head.y - scrollY > window.innerHeight - margin) {
      // serpent proche du bas -> scroll vers le bas (max WORLD_HEIGHT - fenêtre)
      let newScroll = Math.min(WORLD_HEIGHT - window.innerHeight, head.y - window.innerHeight + margin);
      window.scrollTo(0, newScroll);
    }
  }

  // Boucle principale
  function gameLoop() {
    if(!isPaused && playerSnake.alive) {
      playerSnake.update();

      // Vérifier collisions avec nourriture
      for(let i=foods.length-1; i>=0; i--) {
        if(circlesCollide(playerSnake.segments[0].x, playerSnake.segments[0].y, playerSnake.radius, foods[i].x, foods[i].y, foods[i].radius)) {
          foods.splice(i,1);
          playerSnake.grow();
          score++;
          updateScoreDisplay();
        }
      }
    }

    // Nettoyer le canvas (taille viewport)
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Translate le contexte pour simuler la caméra : on décale selon le scroll vertical
    let scrollY = window.scrollY;
    ctx.save();
    ctx.translate(0, -scrollY);

    // Dessiner la zone de jeu
    ctx.fillStyle = '#111';
    ctx.fillRect(0, 0, WORLD_WIDTH, WORLD_HEIGHT);

    // Dessiner bordures
    drawBorders(ctx);

    // Dessiner nourriture
    foods.forEach(food => food.draw(ctx));

    // Dessiner serpent
    playerSnake.draw(ctx);

    ctx.restore();

    // Scroll automatique vertical
    if(!isPaused) autoScroll();

    // Game over
    if(!playerSnake.alive) {
      isPaused = true;
      pauseOverlay.textContent = 'GAME OVER\nTOUCHE POUR REJOUER';
      pauseOverlay.style.display = 'flex';
    }

    requestAnimationFrame(gameLoop);
  }

  // Démarrage initial
  if(pseudo.length === 0) {
    isPaused = true;
    pauseOverlay.style.display = 'flex';
    pauseOverlay.textContent = 'ENTRE TON PSEUDO\nPOUR COMMENCER';
  } else {
    isPaused = false;
    pauseOverlay.style.display = 'none';
    //
