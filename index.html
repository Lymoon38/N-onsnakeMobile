<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>NeonSnake avec scroll automatique</title>
<style>
  body, html {
    margin: 0; padding: 0; overflow-x: hidden;
    background: #111;
    color: #fff;
    font-family: Arial, sans-serif;
  }
  #gameContainer {
    position: relative;
    width: 600px;
    height: 1800px; /* 3x la hauteur de la fenêtre */
    margin: 0 auto;
    background: #222;
    border: 5px solid #f00; /* barrière rouge */
    box-sizing: border-box;
  }
  canvas {
    display: block;
    background: #000;
    margin: 0 auto;
  }
  #score {
    text-align: center;
    margin: 10px 0;
    font-size: 24px;
    color: #0f0;
  }
</style>
</head>
<body>

<div id="score">Score : 0</div>
<div id="gameContainer">
  <canvas id="gameCanvas" width="600" height="600"></canvas>
</div>

<script>
(() => {
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');

  const gameContainer = document.getElementById('gameContainer');
  const scoreDisplay = document.getElementById('score');

  // Zone de jeu (600x1800), serpent dans un canvas 600x600 (viewport)
  const gameWidth = 600;
  const gameHeight = 1800;

  // Serpent initial
  let snake = [
    { x: 10, y: 10 },
    { x: 9, y: 10 },
    { x: 8, y: 10 }
  ];
  const scale = 20; // taille d'une case
  let direction = 'RIGHT';
  let nextDirection = direction;
  let score = 0;
  let gameOver = false;

  // Scroll vertical pour suivre le serpent
  function scrollToSnake() {
    const head = snake[0];
    // position Y en pixels dans la zone de jeu
    const snakeYPixels = head.y * scale;

    // Calcul du scroll top pour que le serpent soit centré verticalement dans la fenêtre
    const scrollTopTarget = snakeYPixels - window.innerHeight / 2 + scale / 2;

    // Limiter le scroll pour ne pas dépasser la zone de jeu
    const maxScroll = gameHeight - window.innerHeight;
    const finalScroll = Math.min(Math.max(scrollTopTarget, 0), maxScroll);

    window.scrollTo({
      top: finalScroll,
      behavior: 'smooth'
    });
  }

  function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Dessiner la barrière (bord de la zone 600x1800 mais on voit que 600x600)
    ctx.strokeStyle = '#f00';
    ctx.lineWidth = 5;
    ctx.strokeRect(0, 0, gameWidth, gameHeight);

    // Dessiner serpent
    ctx.fillStyle = '#0f0';
    snake.forEach(part => {
      // On dessine uniquement les parties du serpent visibles dans le viewport
      const posYInView = part.y * scale - window.scrollY;
      if (posYInView >= -scale && posYInView <= canvas.height) {
        ctx.fillRect(part.x * scale, posYInView, scale, scale);
      }
    });
  }

  function update() {
    if (gameOver) return;

    // Mettre à jour la direction (eviter que le serpent fasse demi-tour direct)
    if (
      (direction === 'LEFT' && nextDirection !== 'RIGHT') ||
      (direction === 'RIGHT' && nextDirection !== 'LEFT') ||
      (direction === 'UP' && nextDirection !== 'DOWN') ||
      (direction === 'DOWN' && nextDirection !== 'UP')
    ) {
      direction = nextDirection;
    }

    // Calcul nouvelle tête selon direction
    let head = { ...snake[0] };
    if (direction === 'LEFT') head.x--;
    else if (direction === 'RIGHT') head.x++;
    else if (direction === 'UP') head.y--;
    else if (direction === 'DOWN') head.y++;

    // Vérifier collision bord
    if (
      head.x < 0 || head.x >= gameWidth / scale ||
      head.y < 0 || head.y >= gameHeight / scale
    ) {
      gameOver = true;
      alert("Game Over ! Vous avez touché la barrière.");
      return;
    }

    // Vérifier collision corps serpent
    for (let part of snake) {
      if (part.x === head.x && part.y === head.y) {
        gameOver = true;
        alert("Game Over ! Vous vous êtes mordu.");
        return;
      }
    }

    // Avancer le serpent (pas de nourriture ici)
    snake.unshift(head);
    snake.pop();

    // Mettre à jour le score (longueur - 3)
    score = snake.length - 3;
    scoreDisplay.textContent = `Score : ${score}`;

    // Scroll pour suivre la tête du serpent
    scrollToSnake();
  }

  // Contrôle clavier
  window.addEventListener('keydown', e => {
    if (e.key === 'ArrowUp') nextDirection = 'UP';
    else if (e.key === 'ArrowDown') nextDirection = 'DOWN';
    else if (e.key === 'ArrowLeft') nextDirection = 'LEFT';
    else if (e.key === 'ArrowRight') nextDirection = 'RIGHT';
  });

  // Game loop
  function gameLoop() {
    update();
    draw();
    if (!gameOver) setTimeout(gameLoop, 150);
  }

  // Initial scroll pour centrer la zone de départ
  window.scrollTo(0, 0);
  gameLoop();

})();
</script>

</body>
</html>
