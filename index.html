<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <title>NeonSnake Multijoueur</title>
  <style>
    body {
      margin: 0;
      background: radial-gradient(ellipse at center, #111 0%, #000 100%);
      overflow: hidden;
    }
    canvas {
      display: block;
      margin: auto;
      background-color: transparent;
    }
  </style>
</head>
<body>
<canvas id="gameCanvas"></canvas>
<script>
  const canvas = document.getElementById("gameCanvas");
  const ctx = canvas.getContext("2d");
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;

  // Serpent
  let snake = [{ x: canvas.width / 2, y: canvas.height / 2 }];
  let snakeLength = 10;
  let score = 0;
  let nickname = prompt("Entrez votre pseudo :") || "Joueur";

  // Orbes lumineux
  let orbs = [];
  for (let i = 0; i < 50; i++) {
    orbs.push({
      x: Math.random() * canvas.width * 4,
      y: Math.random() * canvas.height * 4,
      radius: 5 + Math.random() * 5,
      color: "hsl(" + Math.random() * 360 + ", 100%, 60%)"
    });
  }

  // ContrÃ´le tactile
  let touchX = null, touchY = null;
  let paused = true;

  canvas.addEventListener("touchstart", (e) => {
    const touch = e.touches[0];
    touchX = touch.clientX;
    touchY = touch.clientY;
    paused = false;
  });

  canvas.addEventListener("touchmove", (e) => {
    const touch = e.touches[0];
    touchX = touch.clientX;
    touchY = touch.clientY;
  });

  canvas.addEventListener("touchend", () => {
    paused = true;
  });

  // Fonction de dessin principale
  function draw() {
    // Efface tout le canvas
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Ajoute un voile sombre pour l'effet de traÃ®nÃ©e
    ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    if (!paused && touchX !== null && touchY !== null) {
      const head = snake[0];
      const dx = touchX - canvas.width / 2;
      const dy = touchY - canvas.height / 2;
      const distance = Math.sqrt(dx * dx + dy * dy);
      const speed = 4;
      const vx = dx / distance * speed;
      const vy = dy / distance * speed;

      const newX = head.x + vx;
      const newY = head.y + vy;

      snake.unshift({ x: newX, y: newY });
      while (snake.length > snakeLength) {
        snake.pop();
      }

      // Collision avec les murs
      const boundarySize = 4;
      const gameWidth = canvas.width * boundarySize;
      const gameHeight = canvas.height * boundarySize;
      if (newX < 0 || newY < 0 || newX > gameWidth || newY > gameHeight) {
        alert("ðŸ’¥ Game Over !");
        location.reload();
      }

      // Collision avec les orbes
      for (let i = orbs.length - 1; i >= 0; i--) {
        const orb = orbs[i];
        const dist = Math.hypot(orb.x - newX, orb.y - newY);
        if (dist < 20) {
          orbs.splice(i, 1);
          snakeLength += 3;
          score += 1;
        }
      }
    }

    // Calcul camÃ©ra centrÃ©e sur le joueur
    const offsetX = canvas.width / 2 - snake[0].x;
    const offsetY = canvas.height / 2 - snake[0].y;

    ctx.save();
    ctx.translate(offsetX, offsetY);

    // Bordures rouges/blanches type chantier
    const step = 40;
    for (let i = 0; i < gameWidth; i += step) {
      ctx.fillStyle = (i / step) % 2 === 0 ? "red" : "white";
      ctx.fillRect(i, 0, step, 20);
      ctx.fillRect(i, gameHeight - 20, step, 20);
    }
    for (let i = 0; i < gameHeight; i += step) {
      ctx.fillStyle = (i / step) % 2 === 0 ? "red" : "white";
      ctx.fillRect(0, i, 20, step);
      ctx.fillRect(gameWidth - 20, i, 20, step);
    }

    // Orbes lumineux
    for (let orb of orbs) {
      ctx.beginPath();
      ctx.arc(orb.x, orb.y, orb.radius, 0, 2 * Math.PI);
      ctx.fillStyle = orb.color;
      ctx.shadowBlur = 20;
      ctx.shadowColor = orb.color;
      ctx.fill();
    }

    // Serpent
    for (let i = 0; i < snake.length; i++) {
      const s = snake[i];
      const hue = (i * 10) % 360;
      ctx.beginPath();
      ctx.arc(s.x, s.y, 10, 0, 2 * Math.PI);
      ctx.fillStyle = `hsl(${hue}, 100%, 60%)`;
      ctx.shadowBlur = 15;
      ctx.shadowColor = `hsl(${hue}, 100%, 60%)`;
      ctx.fill();
    }

    // Yeux
    const head = snake[0];
    ctx.beginPath();
    ctx.arc(head.x - 5, head.y - 5, 3, 0, 2 * Math.PI);
    ctx.arc(head.x + 5, head.y - 5, 3, 0, 2 * Math.PI);
    ctx.fillStyle = "#fff";
    ctx.fill();

    ctx.restore();

    // Affichage score/pseudo
    ctx.fillStyle = "#0f0";
    ctx.font = "20px Arial";
    ctx.shadowBlur = 0;
    ctx.fillText(`${nickname} : ${score}`, 20, 30);
  }

  setInterval(draw, 1000 / 60);
</script>
</body>
</html>
