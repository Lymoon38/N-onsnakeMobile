<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
<title>NeonSnake Multijoueur</title>
<style>
  /* --- Style Néon et visuel général --- */
  body, html {
    margin: 0; padding: 0; overflow: hidden;
    background: #0a0a0a;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    color: #eee;
    user-select: none;
    -webkit-tap-highlight-color: transparent;
  }
  canvas {
    display: block;
    background: #111111;
    margin: 0 auto;
    box-shadow:
      0 0 10px #00f0ff,
      0 0 20px #00f0ff,
      0 0 30px #00f0ff;
    border-radius: 8px;
  }
  #scoreboard {
    position: fixed;
    top: 10px; left: 50%;
    transform: translateX(-50%);
    background: rgba(0,0,0,0.5);
    padding: 8px 12px;
    border-radius: 12px;
    font-size: 18px;
    letter-spacing: 1.2px;
    box-shadow:
      0 0 8px #0ff, 
      0 0 20px #0ff inset;
  }
  #pseudoInput {
    position: fixed;
    top: 50px; left: 50%;
    transform: translateX(-50%);
    padding: 6px 10px;
    border-radius: 8px;
    border: none;
    font-size: 16px;
    width: 140px;
    outline: none;
    box-shadow:
      0 0 8px #0ff,
      0 0 15px #0ff inset;
    background: #222;
    color: #0ff;
  }
  #pauseOverlay {
    position: fixed;
    top:0; left:0; right:0; bottom:0;
    background: rgba(10,10,10,0.75);
    display: flex;
    justify-content: center;
    align-items: center;
    color: #0ff;
    font-size: 48px;
    font-weight: bold;
    user-select: none;
    cursor: pointer;
    display: none;
    z-index: 10;
    text-shadow:
      0 0 10px #0ff,
      0 0 20px #0ff,
      0 0 30px #0ff;
  }
</style>
</head>
<body>
<!-- Score et pseudo -->
<div id="scoreboard">Score: 0</div>
<input type="text" id="pseudoInput" maxlength="10" placeholder="Ton pseudo" />

<!-- Pause Overlay -->
<div id="pauseOverlay">PAUSE<br>Appuie pour reprendre</div>

<!-- Canvas pour le jeu -->
<canvas id="gameCanvas" width="800" height="600"></canvas>

<script>
(() => {
  // --- CONSTANTES & VARIABLES GLOBALES ---
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');
  const scoreboard = document.getElementById('scoreboard');
  const pseudoInput = document.getElementById('pseudoInput');
  const pauseOverlay = document.getElementById('pauseOverlay');

  // Zone de jeu 4x plus grande que le canvas visible
  const WORLD_WIDTH = canvas.width * 4;
  const WORLD_HEIGHT = canvas.height * 4;

  // Taille d’un anneau du serpent
  const SEGMENT_SIZE = 20;

  // Barrière style chantier (rouge/blanc)
  const BARRIER_WIDTH = 40;

  // Points lumineux à manger
  const FOOD_COUNT = 30;

  // Score et pseudo
  let score = 0;
  let pseudo = localStorage.getItem('neonsnake_pseudo') || '';
  pseudoInput.value = pseudo;

  // Pause automatique et contrôle tactile
  let isPaused = true;

  // Multijoueur : websocket
  let ws;

  // --- CLASSES / OBJETS ---

  class Vector2 {
    constructor(x, y) {
      this.x = x;
      this.y = y;
    }
    add(v) {
      return new Vector2(this.x + v.x, this.y + v.y);
    }
    subtract(v) {
      return new Vector2(this.x - v.x, this.y - v.y);
    }
    multiply(s) {
      return new Vector2(this.x * s, this.y * s);
    }
    length() {
      return Math.sqrt(this.x * this.x + this.y * this.y);
    }
    normalized() {
      const len = this.length();
      return len === 0 ? new Vector2(0, 0) : new Vector2(this.x / len, this.y / len);
    }
  }

  // --- SERPENT ---
  class Snake {
    constructor(color, startX, startY) {
      this.color = color;
      this.segments = [];
      this.direction = new Vector2(1, 0); // vers la droite initialement
      this.nextDirection = this.direction;
      this.growAmount = 0;
      this.alive = true;
      this.position = new Vector2(startX, startY);
      this.speed = 3; // pixels/frame
      this.eyes = [
        new Vector2(7, -8),  // oeil gauche
        new Vector2(7, 8),   // oeil droit
      ];
      // Init avec 10 segments alignés vers la gauche
      for(let i=0; i<10; i++) {
        this.segments.push(this.position.add(new Vector2(-i*SEGMENT_SIZE, 0)));
      }
    }

    update() {
      if(!this.alive) return;

      // Update direction doucement vers nextDirection (évite rotations brutales)
      const angleCurrent = Math.atan2(this.direction.y, this.direction.x);
      const angleTarget = Math.atan2(this.nextDirection.y, this.nextDirection.x);
      let deltaAngle = angleTarget - angleCurrent;
      if(deltaAngle > Math.PI) deltaAngle -= 2 * Math.PI;
      if(deltaAngle < -Math.PI) deltaAngle += 2 * Math.PI;
      const maxTurn = 0.15;
      let newAngle = angleCurrent;
      if(Math.abs(deltaAngle) > maxTurn) {
        newAngle += deltaAngle > 0 ? maxTurn : -maxTurn;
      } else {
        newAngle = angleTarget;
      }
      this.direction = new Vector2(Math.cos(newAngle), Math.sin(newAngle));

      // Avance la tête
      const newHead = this.segments[0].add(this.direction.multiply(this.speed));

      // Insert nouvelle tête
      this.segments.unshift(newHead);

      if(this.growAmount > 0) {
        this.growAmount--;
      } else {
        this.segments.pop();
      }

      // Vérifie collision avec murs (barrières rouges/blanches)
      if(newHead.x < BARRIER_WIDTH || newHead.x > WORLD_WIDTH - BARRIER_WIDTH ||
         newHead.y < BARRIER_WIDTH || newHead.y > WORLD_HEIGHT - BARRIER_WIDTH) {
        this.alive = false;
      }

      // Vérifie collision avec lui-même (sauf tête et 3 premiers segments)
      for(let i=4; i < this.segments.length; i++) {
        if(distance(this.segments[i], newHead) < SEGMENT_SIZE / 2) {
          this.alive = false;
          break;
        }
      }
    }

    grow(amount=5) {
      this.growAmount += amount;
    }

    setDirection(vec) {
      // Evite de se retourner directement
      if(this.direction.x * vec.x + this.direction.y * vec.y < 0) return;
      this.nextDirection = vec.normalized();
    }

    draw(ctx, offsetX, offsetY) {
      // Dessine chaque segment avec un effet néon (anneaux colorés)
      for(let i = this.segments.length - 1; i >= 0; i--) {
        const seg = this.segments[i];
        const x = seg.x - offsetX;
        const y = seg.y - offsetY;

        // Anneaux néon avec cercles concentriques
        const radius = SEGMENT_SIZE / 2;
        let alpha = 1 - i / this.segments.length;
        alpha = Math.max(alpha, 0.3);

        ctx.lineWidth = 2;
        ctx.shadowColor = this.color;
        ctx.shadowBlur = 15;

        // Cercle principal
        ctx.beginPath();
        ctx.strokeStyle = `rgba(${this.color.r},${this.color.g},${this.color.b},${alpha})`;
        ctx.fillStyle = `rgba(${this.color.r},${this.color.g},${this.color.b},${alpha*0.4})`;
        ctx.arc(x, y, radius, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();

        // Cercles internes plus clairs
        ctx.beginPath();
        ctx.strokeStyle = `rgba(255,255,255,${alpha*0.15})`;
        ctx.arc(x, y, radius*0.6, 0, Math.PI*2);
        ctx.stroke();

        ctx.beginPath();
        ctx.strokeStyle = `rgba(255,255,255,${alpha*0.1})`;
        ctx.arc(x, y, radius*0.3, 0, Math.PI*2);
        ctx.stroke();

        ctx.shadowBlur = 0;
      }

      // Dessine les yeux au-dessus de la tête, toujours visibles
      if(this.segments.length > 0) {
        const head = this.segments[0];
        const baseX = head.x - offsetX + this.eyes[0].x;
        const baseY = head.y - offsetY + this.eyes[0].y;
        const eyeRadius = 4;

        ctx.fillStyle = "#0ff";
        ctx.shadowColor = "#0ff";
        ctx.shadowBlur = 10;

        // Oeil gauche
        ctx.beginPath();
        ctx.arc(baseX, baseY, eyeRadius, 0, Math.PI * 2);
        ctx.fill();

        // Oeil droit
        ctx.beginPath();
        ctx.arc(baseX, baseY + 16, eyeRadius, 0, Math.PI * 2);
        ctx.fill();

        // Pupilles noires
        ctx.fillStyle = "#000";
        ctx.shadowBlur = 0;

        ctx.beginPath();
        ctx.arc(baseX, baseY, eyeRadius/2, 0, Math.PI*2);
        ctx.fill();

        ctx.beginPath();
        ctx.arc(baseX, baseY + 16, eyeRadius/2, 0, Math.PI*2);
        ctx.fill();
      }
    }
  }

  // --- NOURRITURE (points lumineux) ---
  class Food {
    constructor(x, y) {
      this.position = new Vector2(x, y);
      this.radius = 8;
    }
    draw(ctx, offsetX, offsetY) {
      const x = this.position.x - offsetX;
      const y = this.position.y - offsetY;

      // Point lumineux néon bleu clair
      const gradient = ctx.createRadialGradient(x, y, 0, x, y, this.radius);
      gradient.addColorStop(0, 'rgba(0, 255, 255, 1)');
      gradient.addColorStop(1, 'rgba(0, 255, 255, 0)');

      ctx.fillStyle = gradient;
      ctx.beginPath();
      ctx.arc(x, y, this.radius, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  // --- UTILITAIRES ---
  function distance(v1, v2) {
    return Math.sqrt((v1.x - v2.x)**2 + (v1.y - v2.y)**2);
  }

  function randomRange(min, max) {
    return Math.random() * (max - min) + min;
  }

  // --- GESTION DU JEU ---

  // Le serpent joueur (unique local)
  const snakeColor = {r:0, g:255, b:255};
  let playerSnake = new Snake(snakeColor, WORLD_WIDTH/2, WORLD_HEIGHT/2);

  // Nourriture générée aléatoirement
  let foods = [];

  function generateFoods() {
    foods = [];
    for(let i=0; i<FOOD_COUNT; i++) {
      let x, y, safe;
      do {
        safe = true;
        x = randomRange(BARRIER_WIDTH + 20, WORLD_WIDTH - BARRIER_WIDTH - 20);
        y = randomRange(BARRIER_WIDTH + 20, WORLD_HEIGHT - BARRIER_WIDTH - 20);
        // Evite de générer trop proche du serpent au départ
        if(distance(new Vector2(x,y), playerSnake.segments[0]) < 100) safe = false;
      } while(!safe);
      foods.push(new Food(x, y));
    }
  }
  generateFoods();

  // Décalage caméra pour centrer le serpent
  let cameraX = 0;
  let cameraY = 0;

  // --- GESTION CONTROLE TACTILE ---
  let touchActive = false;
  let lastTouchX = null;
  let lastTouchY = null;

  canvas.addEventListener('touchstart', (e) => {
    e.preventDefault();
    if(isPaused) {
      isPaused = false;
      pauseOverlay.style.display = 'none';
    }
    touchActive = true;
    const t = e.touches[0];
    lastTouchX = t.clientX;
    lastTouchY = t.clientY;
  });

  canvas.addEventListener('touchmove', (e) => {
    e.preventDefault();
    if(!touchActive) return;
    const t = e.touches[0];
    const dx = t.clientX - lastTouchX;
    const dy = t.clientY - lastTouchY;

    // Calcul direction par vecteur (dx, dy)
    if(dx !== 0 || dy !== 0) {
      playerSnake.setDirection(new Vector2(dx, dy));
      lastTouchX = t.clientX;
      lastTouchY = t.clientY;
    }
  });

  canvas.addEventListener('touchend', (e) => {
    e.preventDefault();
    touchActive = false;
    // Pause automatique quand on arrête de toucher
    isPaused = true;
    pauseOverlay.style.display = 'flex';
  });

  pauseOverlay.addEventListener('click', () => {
    if(isPaused) {
      isPaused = false;
      pauseOverlay.style.display = 'none';
    }
  });

  // --- GESTION SCORE ET PSEUDO ---
  function updateScoreDisplay() {
    scoreboard.textContent = `Score: ${score}`;
  }
  pseudoInput.addEventListener('input', () => {
    pseudo = pseudoInput.value.trim().substring(0,10);
    localStorage.setItem('neonsnake_pseudo', pseudo);
  });

  // --- COLLISION NOURRITURE ---
  function checkFoodCollision() {
    for(let i = foods.length -1; i>=0; i--) {
      if(distance(playerSnake.segments[0], foods[i].position) < SEGMENT_SIZE) {
        foods.splice(i,1);
        playerSnake.grow(3);
        score += 10;
        updateScoreDisplay();
        // Ajout de nouveau point alimentaire
        generateFoods();
      }
    }
  }

  // --- DESSIN BARRIERE ---
  function drawBarriers() {
    const bw = BARRIER_WIDTH;
    const patternSize = 20;

    // Dessine les 4 côtés de la zone avec motif rouge/blanc style chantier

    // Top
    for(let x=0; x<WORLD_WIDTH; x+=patternSize*2) {
      drawBarrierBlock(x, 0, patternSize);
    }
    // Bottom
    for(let x=0; x<WORLD_WIDTH; x+=patternSize*2) {
      drawBarrierBlock(x, WORLD_HEIGHT - bw, patternSize);
    }
    // Left
    for(let y=0; y<WORLD_HEIGHT; y+=patternSize*2) {
      drawBarrierBlock(0, y, patternSize, true);
    }
    // Right
    for(let y=0; y<WORLD_HEIGHT; y+=patternSize*2) {
      drawBarrierBlock(WORLD_WIDTH - bw, y, patternSize, true);
    }
  }

  // Barre rouge/blanche en damier pour barrières
  function drawBarrierBlock(x, y, size, vertical=false) {
    const colors = ['#ff0000', '#ffffff'];
    ctx.save();
    ctx.translate(x, y);
    for(let i=0; i<2; i++) {
      ctx.fillStyle = colors[i];
      if(vertical) {
        ctx.fillRect(0, i*size, size, size);
      } else {
        ctx.fillRect(i*size, 0, size, size);
      }
    }
    ctx.restore();
  }

  // --- MAIN LOOP ---
  function gameLoop() {
    if(!isPaused && playerSnake.alive) {
      playerSnake.update();
      checkFoodCollision();
    }

    // Centre caméra sur la tête du serpent, en limitant dans la zone
    cameraX = playerSnake.segments[0].x - canvas.width / 2;
    cameraY = playerSnake.segments[0].y - canvas.height / 2;
    cameraX = Math.min(Math.max(cameraX, 0), WORLD_WIDTH - canvas.width);
    cameraY = Math.min(Math.max(cameraY, 0), WORLD_HEIGHT - canvas.height);

    // Nettoie l’écran
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Dessine barrières
    drawBarriers();

    // Dessine nourriture
    for(let food of foods) {
      food.draw(ctx, cameraX, cameraY);
    }

    // Dessine serpent
    playerSnake.draw(ctx, cameraX, cameraY);

    // Game Over ?
    if(!playerSnake.alive) {
      isPaused = true;
      pauseOverlay.textContent = 'GAME OVER\nAppuie pour rejouer';
      pauseOverlay.style.display = 'flex';
    }

    requestAnimationFrame(gameLoop);
  }

  // --- REINITIALISATION ---
  function resetGame() {
    score = 0;
    updateScoreDisplay();
    playerSnake = new Snake(snakeColor, WORLD_WIDTH/2, WORLD_HEIGHT/2);
    generateFoods();
    isPaused = false;
    pauseOverlay.style.display = 'none';
  }

  pauseOverlay.addEventListener('click', () => {
    if(!playerSnake.alive) {
      resetGame();
    }
  });

  // --- INITIALISATION ---
  updateScoreDisplay();
  if(pseudo) {
    isPaused = false;
    pauseOverlay.style.display = 'none';
  } else {
    isPaused = true;
    pauseOverlay.style.display = 'flex';
  }
  gameLoop();

  // --- MULTIJOUEUR (exemple simplifié) ---
  // Attention: ce code suppose que vous avez un serveur websocket 
  // sur ws://votre-serveur-neonsnake.example/ws qui gère les joueurs et leur positions
  // Ici on ne gère que la connexion et envoi des positions.

  /*
  function initWebSocket() {
    ws = new WebSocket('ws://votre-serveur-neonsnake.example/ws');

    ws.onopen = () => {
      console.log('WebSocket connecté');
      ws.send(JSON.stringify({
        type: 'join',
        pseudo: pseudo,
      }));
    };

    ws.onmessage = (event) => {
      const data = JSON.parse(event.data);
      // Gestion des données des autres joueurs, à implémenter
      // (affichage, position, etc.)
    };

    ws.onclose = () => {
      console.log('WebSocket déconnecté');
    };

    ws.onerror = (err) => {
      console.error('Erreur WebSocket', err);
    };
  }

  // Envoi périodique de la position du joueur
  setInterval(() => {
    if(ws && ws.readyState === WebSocket.OPEN && playerSnake.alive && !isPaused) {
      ws.send(JSON.stringify({
        type: 'position',
        x: playerSnake.segments[0].x,
        y: playerSnake.segments[0].y,
        pseudo: pseudo,
        score: score,
      }));
    }
  }, 100);
  
  // Init la connexion
  initWebSocket();
  */

  // Note: Sans serveur WebSocket actif, le multijoueur ne fonctionnera pas.
  // Vous pouvez retirer ou désactiver ce bloc pour tester en solo.

})();
</script>
</body>
</html>
